# Vue题目汇总

- [按要求完成题目](#按要求完成题目)
- [Redux 和 Vuex 有什么区别，说下一它们的共同思想](#redux-和-vuex-有什么区别说下一它们的共同思想) ✅
- [说一下对 React 和 Vue 的理解，它们的异同](#说一下对-react-和-vue-的理解它们的异同) ✅
- [对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？](#对虚拟-dom-的理解虚拟-dom-主要做了什么虚拟-dom-本身是什么) ✅
- [介绍单页应用和多页应用？](#介绍单页应用和多页应用) ✅
- [说一下 Vue3 与 Vue2 的对比](#说一下-vue3-与-vue2-的对比) ✅
- [vue 对数组的方法做了重写的操作，如何实现对 vue2 中对数组操作的 push()方法](#vue-对数组的方法做了重写的操作如何实现对-vue2-中对数组操作的-push方法) ✅
- [简述 Vue 的基本原理](#简述-vue-的基本原理) ✅
- [简述 Vue 的生命周期以及每个阶段做的事](#简述-vue-的生命周期以及每个阶段做的事) ✅
- [说一下 Vue 组件的通信方式都有哪些？(父子组件，兄弟组件，多级嵌套组件等等)](#说一下-vue-组件的通信方式都有哪些父子组件兄弟组件多级嵌套组件等等) ✅
- [说一下 Vuex 的原理以及自己的理解](#说一下-vuex-的原理以及自己的理解) ✅
- [Vue v-model 是如何实现的，语法糖实际是什么](#vue-v-model-是如何实现的语法糖实际是什么) ✅
- [说一下 Vue dom diff 算法](#说一下-vue-dom-diff-算法) ✅
- [说一下 Vue 的$nextTick 原理](#说一下-vue-的nexttick-原理) ✅
- [说一下 vue-router 的原理](#说一下-vue-router-的原理) ✅
- [Vue 是如何收集依赖的](#vue-是如何收集依赖的) ✅
- [说一下 Vue 单页与多页的区别](#说一下-vue-单页与多页的区别) ✅
- [说一下 Vue 路由实现原理](#说一下-vue-路由实现原理) ✅
- [Vue3.0 为什么要用 proxy？是怎么用 proxy 实现数据监听的?](#vue30-为什么要用-proxy是怎么用-proxy-实现数据监听的) ✅
- [说一下对 vue3.0 的了解，vue3.0 为什么要用代理](#说一下对-vue30-的了解vue30-为什么要用代理) ✅
- [子组件可以直接改变父组件的数据么，说明原因](#子组件可以直接改变父组件的数据么说明原因) ✅
- [Vue 中一次性 200 条弹幕怎么处理](#vue-中一次性-200-条弹幕怎么处理) ✅
- [vue hooks 有哪些](#vue-hooks-有哪些) ✅
- [介绍 Vue template 到 render 的过程](#介绍-vue-template-到-render-的过程) ✅
- [怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？](#怎么定义-vue-router-的动态路由怎么获取传过来的动态参数) ✅
- [下面关于 Vue 说法正确的是？(单选题)](#下面关于-vue-说法正确的是单选题) ✅
- [为什么要用 Vuex 或者 Redux，不要说为了保存状态](#为什么要用-vuex-或者-redux不要说为了保存状态) ✅
- [为什么 Vue data 必须是函数](#为什么-vue-data-必须是函数) ✅
- [Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？](#vue-data-中某一个属性的值发生改变后视图会立即同步执行重新渲染吗) ✅
- [简述 mixin、extends 的覆盖逻辑](#简述-mixinextends-的覆盖逻辑) ✅
- [Vue 子组件和父组件执行顺序](#vue-子组件和父组件执行顺序) ✅
- [Vuex 和 localStorage 的区别](#vuex-和-localstorage-的区别) ✅
- [Vue 双向绑定原理](#vue-双向绑定原理) ✅
- [说一下路由钩子在 Vue 生命周期的体现？](#说一下路由钩子在-vue-生命周期的体现) ✅
- [计算属性和普通属性的区别](#计算属性和普通属性的区别) ✅
- [描述下自定义指令(你是怎么用自定义指令的)](#描述下自定义指令你是怎么用自定义指令的) ✅
- [说一下 Vue 中所有带$的方法](#说一下-vue-中所有带的方法) ✅
- [Vue-router 除了 router-link 怎么实现跳转](#vue-router-除了-router-link-怎么实现跳转) ✅
- [说一下 Vue 的 keep-alive 是如何实现的，具体缓存的是什么？](#说一下-vue-的-keep-alive-是如何实现的具体缓存的是什么) ✅

### 按要求完成题目

```js
/* 
  a)在不使用vue、react的前提下写代码解决一下问题
    一个List页面上，含有1000个条目的待办列表，现其中100项在同一时间达到了过期时间，需要在对应项的text-node里添加“已过期”文字。需要尽可能减少dom重绘次数以提升性能。
  b)尝试使用vue或react解决上述问题
*/
```

公司：爱范儿

分类：JavaScript、Vue、React、编程题

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/848)
a) 不使用Vue或React解决问题：

对于这个问题，你可以使用普通的JavaScript和DOM操作来解决。主要思路是找到过期的条目并添加“已过期”文字，同时尽量减少DOM重绘。

```html
<!DOCTYPE html>
<html>
<head>
    <title>待办列表</title>
</head>
<body>
    <ul id="todoList">
        <!-- 这里包含1000个待办事项 -->
    </ul>

    <script>
        // 模拟数据，100个已过期的事项的索引
        const expiredIndexes = [/* 100个过期事项的索引 */];

        const todoList = document.getElementById('todoList');
        const items = todoList.getElementsByTagName('li');

        for (let i = 0; i < items.length; i++) {
            // 检查当前索引是否在已过期的列表中
            if (expiredIndexes.includes(i)) {
                // 添加“已过期”文字
                items[i].textContent = items[i].textContent + ' 已过期';
            }
        }
    </script>
</body>
</html>
```

在上面的示例中，我们首先模拟了100个已过期事项的索引，然后遍历待办列表中的每个条目，检查索引是否在已过期的列表中，如果是，则在该条目的text-node上添加“已过期”文字。这种方法可以减少DOM重绘的次数，因为我们一次性处理了所有过期的条目。

b) 使用Vue或React解决问题：

在Vue或React中，可以更方便地管理数据和视图，减少手动DOM操作的需求。以下是两种方法：

**Vue解决方法**：

```vue
<template>
  <div>
    <ul>
      <li v-for="(item, index) in todoList" :key="index">{{ item.text }} {{ isExpired(index) }}</li>
    </ul>
  </div>
</template>

<script>
export default {
  data() {
    return {
      todoList: [/* 包含1000个待办事项的数据 */],
      expiredIndexes: [/* 包含100个已过期事项的索引 */]
    };
  },
  methods: {
    isExpired(index) {
      return this.expiredIndexes.includes(index) ? '已过期' : '';
    }
  }
};
</script>
```

在Vue中，我们使用`v-for`指令来渲染待办列表，使用`isExpired`方法来检查是否过期并在相应的列表项中添加文字。

**React解决方法**：

```jsx
import React from 'react';

class TodoList extends React.Component {
  constructor() {
    super();
    this.state = {
      todoList: [/* 包含1000个待办事项的数据 */],
      expiredIndexes: [/* 包含100个已过期事项的索引 */]
    };
  }

  isExpired(index) {
    return this.state.expiredIndexes.includes(index) ? '已过期' : '';
  }

  render() {
    return (
      <div>
        <ul>
          {this.state.todoList.map((item, index) => (
            <li key={index}>{item.text} {this.isExpired(index)}</li>
          ))}
        </ul>
      </div>
    );
  }
}
```

在React中，我们使用状态来管理待办列表和已过期事项的索引，并在`render`方法中渲染列表项，并根据是否过期来添加文字。

在Vue和React中，框架会自动处理DOM更新，从而减少手动DOM操作的需求，提升了开发效率和性能。

<br/>

### Redux 和 Vuex 有什么区别，说下一它们的共同思想

公司：快手

分类：React、Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/206)
Redux和Vuex都是用于管理应用程序状态的状态管理库，它们有很多相似之处，因为Vuex受到了Redux的启发。现在，让我为你详细解释它们之间的区别和共同思想。

#### 共同思想：

1. **单一数据源：**
   - **Redux：** 应用中的整个状态被存储在一个单一的不可变对象中，称为"store"。
   - **Vuex：** 同样，整个应用的状态也被保存在一个称为"store"的单一对象中。

2. **状态不可变性：**
   - **Redux：** 状态是不可变的，任何状态的变更都通过创建一个新的状态对象来完成。
   - **Vuex：** 也鼓励状态的不可变性，通过类似的方式更新状态。

3. **Actions：**
   - **Redux：** 通过Actions来描述对状态的更改。Actions是纯粹的JavaScript对象，包含`type`字段来指示要执行的操作。
   - **Vuex：** 同样，使用Actions来触发状态的变化。

4. **Mutations：**
   - **Redux：** 使用纯函数（pure functions）称为reducers来处理Actions，返回一个新的状态。
   - **Vuex：** 使用Mutations，也是一种纯函数，用于同样的目的。

#### 区别：

1. **语法和API差异：**
   - **Redux：** 采用纯JavaScript，使用纯函数作为reducer。
   - **Vuex：** 基于Vue.js，使用了一些Vue的语法，例如`mapState`，`mapGetters`等。

2. **框架依赖性：**
   - **Redux：** 不依赖于任何特定的框架，可以与React等配合使用。
   - **Vuex：** 是Vue.js的官方状态管理库，紧密集成在Vue生态系统中。

3. **工具和生态系统：**
   - **Redux：** 有丰富的中间件和开发工具，如Redux DevTools，用于调试和跟踪状态的变化。
   - **Vuex：** 有一些类似的工具，但相对Redux来说生态系统规模较小。

4. **模块化：**
   - **Redux：** 可以通过组合reducer来实现模块化。
   - **Vuex：** 提供了模块化的方式，可以将store拆分为多个模块。

总体而言，Redux和Vuex在核心思想上非常相似，但它们在具体实现和语法上有所不同，取决于所使用的框架和开发者

<br/>

### 说一下对 React 和 Vue 的理解，它们的异同

公司：网易、脉脉、快手

分类：React、Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/347)
React和Vue是两个流行的前端JavaScript框架，用于构建用户界面。它们有一些相似之处，但也有一些明显的区别。下面是对它们的理解以及它们的异同之处：

#### React：

**理解：**
- React是一个由Facebook开发的JavaScript库，用于构建用户界面。它的核心思想是组件化，将用户界面拆分成多个可重用的组件。
- React使用虚拟DOM（Virtual DOM）来提高性能，它在内存中维护一个虚拟的DOM树，与实际的DOM进行比较，然后只更新必要的部分，以避免不必要的DOM操作。
- React采用一种声明式的方式来描述UI，通过组件的状态（state）和属性（props）来管理数据和UI渲染。
- React社区庞大，有大量的第三方库和组件，可以帮助开发者构建功能丰富的应用程序。

**异同：**

1. **语法和渲染方式：**
   - React使用JSX（JavaScript XML）语法，将UI表示为组件的层次结构。Vue使用模板语法，将UI表示为HTML模板。
   - React采用虚拟DOM来更新实际的DOM，而Vue直接操作实际的DOM。

2. **生态系统：**
   - React生态系统包括众多的库和工具，如React Router用于路由管理，Redux用于状态管理。
   - Vue提供了Vue Router和Vuex等官方库，使得构建SPA（单页应用）更加一体化。

3. **学习曲线：**
   - React通常被认为具有更陡峭的学习曲线，因为它需要理解JSX和一些概念如组件生命周期。
   - Vue被认为对初学者更友好，因为它的模板语法更接近常规HTML。

4. **社区和支持：**
   - React拥有庞大的社区和支持，适用于大型项目和企业级应用。
   - Vue社区相对较小，但也在不断增长，适用于快速原型开发和小型到中型项目。

5. **状态管理：**
   - React没有内建的状态管理工具，但通常与Redux、MobX等第三方库一起使用。
   - Vue提供了Vuex作为官方状态管理工具，使状态管理更容易。

#### Vue：

**理解：**
- Vue是一个渐进式的JavaScript框架，设计用于构建用户界面。它由尤雨溪（Evan You）创建，强调简单性和灵活性。
- Vue将UI表示为组件，每个组件可以包含模板、脚本和样式，使得组件化开发变得非常容易。
- Vue的核心是响应式数据绑定，通过将数据和UI绑定在一起，可以实现自动更新。
- Vue还提供了一些官方工具，如Vue Router用于路由管理，Vuex用于状态管理。

总结来说，React更注重组件和灵活性，适合大型和复杂应用，而Vue更注重简单性和快速上手，适合中小型项目和快速原型开发。选择React还是Vue取决于项目需求、开发团队的经验和个人偏好。

<br/>

### 对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？

公司：有赞、微医、58

分类：React、Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/479)
虚拟DOM（Virtual DOM）是React和其他一些前端框架（如Vue）中的一个重要概念。它是一个在内存中维护的轻量级的JavaScript对象树，用于表示实际DOM的抽象。

**虚拟DOM的主要作用：**
1. **性能优化：** 虚拟DOM通过在内存中进行操作，减少了直接操作实际DOM的次数，从而提高了性能。实际DOM的操作是相对昂贵的，而虚拟DOM可以批量更新，只更新必要的部分，减少了浏览器的重绘和回流。
2. **跨平台兼容性：** 虚拟DOM可以在不同平台上运行，因为它只是一个JavaScript对象，不依赖于具体的浏览器API。这使得React等框架可以在服务器端渲染、移动端和桌面端等不同环境中使用。

**虚拟DOM的工作原理：**
1. **初始渲染：** 当React组件首次渲染时，会创建一个虚拟DOM树，该树与实际的DOM结构相对应。虚拟DOM树是由React元素（Element）构成的，每个元素描述了一个DOM节点。
2. **更新过程：** 当组件的状态（state）或属性（props）发生变化时，React会生成一个新的虚拟DOM树，与之前的虚拟DOM树进行比较，找出需要更新的部分。
3. **差异计算：** 虚拟DOM树的比较过程称为差异计算（Diffing），React使用一种高效的算法来找出两个树之间的差异。这些差异通常是添加、删除或更新DOM节点。
4. **批量更新：** React将所有的差异记录下来，并将它们批量应用到实际的DOM中，最小化对实际DOM的操作次数。
5. **实际DOM更新：** 最后，React将差异应用到实际的DOM上，使得实际DOM与虚拟DOM保持同步。

**虚拟DOM的本质：**
虚拟DOM本质上是一个JavaScript对象，它是对实际DOM的抽象表示。它包含了DOM节点的层次结构、属性、样式等信息。通过使用虚拟DOM，框架可以在内存中进行操作，然后将更改应用到实际DOM上，以提高性能和跨平台兼容性。虚拟DOM的存在使得开发者可以专注于数据和UI的变化，而不必过多关注底层的DOM操作。

<br/>

### 介绍单页应用和多页应用？

公司：寺库、海康威视

分类：React、Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/593)
单页应用（Single-Page Application，SPA）和多页应用（Multiple-Page Application，MPA）是两种常见的Web应用程序架构。

**单页应用（SPA）：**
单页应用是指在加载初始HTML页面后，所有的页面交互都在同一个页面中完成，不需要重新加载整个页面。SPA通常使用JavaScript框架（如React、Angular、Vue等）来实现前端逻辑和路由控制。SPA的特点包括：
1. **动态加载内容：** SPA通过AJAX或WebSocket等技术从服务器获取数据，然后使用JavaScript动态更新页面内容，而不是重新加载整个页面。
2. **前端路由：** SPA使用前端路由来管理不同页面之间的切换，通过改变URL来加载不同的组件或视图。
3. **更好的用户体验：** SPA提供了更快的页面切换和响应速度，因为只需要加载和渲染部分内容，用户可以无缝地进行交互。

**多页应用（MPA）：**
多页应用是指每个页面都是一个独立的HTML文件，每次用户进行页面切换时，都需要重新加载整个页面。MPA通常使用后端渲染技术（如PHP、Java、Python等）来生成不同的HTML页面。MPA的特点包括：
1. **页面刷新：** MPA在页面切换时需要重新加载整个页面，因此会有页面刷新的延迟。
2. **服务器端渲染：** MPA通常使用服务器端渲染技术，每次请求都会由服务器生成一个新的HTML页面。
3. **独立页面：** MPA中每个页面都是独立的，它们之间没有共享的状态或数据。

**比较：**
1. **性能：** SPA在初始加载时可能需要较长的时间，但后续页面切换会更快，因为只需要加载和渲染部分内容。而MPA在每次页面切换时都需要重新加载整个页面，可能会有较长的延迟。
2. **用户体验：** SPA提供了更流畅的用户体验，因为页面切换不需要重新加载整个页面。而MPA在页面切换时会有页面刷新的延迟，用户体验可能相对较差。
3. **开发复杂度：** SPA通常需要使用前端框架来管理路由和状态，开发复杂度相对较高。而MPA使用后端渲染技术，开发复杂度相对较低。

选择SPA还是MPA取决于具体的应用需求和开发团队的技术栈。SPA适用于需要快速响应和良好用户体验的应用，而MPA适用于传统的多页面应用或需要SEO优化的场景。

<br/>

### 说一下 Vue3 与 Vue2 的对比 

公司：高德

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/302)
Vue3是Vue.js框架的最新版本，相比于Vue2，它引入了一些重要的改进和新特性。下面是Vue3与Vue2的对比：

**1. 性能提升：**
- **更快的渲染速度：** Vue3使用了重写的响应式系统，使得在大型应用中的渲染速度比Vue2更快。
- **更小的包体积：** Vue3通过优化内部代码和使用Tree-shaking技术，使得打包后的文件更小，减少了用户下载和加载的时间。

**2. Composition API：**
- **更灵活的组合式开发：** Vue3引入了Composition API，它允许开发者根据逻辑相关性组织代码，而不是按照组件的生命周期钩子函数。这使得代码更易于维护和重用。
- **更好的类型推导：** Composition API在类型推导方面更强大，使得在开发过程中更容易发现错误和提供更好的开发工具支持。

**3. 更好的 TypeScript 支持：**
- **TypeScript 支持改进：** Vue3对TypeScript的支持更加完善，提供了更好的类型推导和错误检查，使得在使用TypeScript开发Vue应用时更加方便和可靠。

**4. 更好的响应式系统：**
- **Proxy 替代 Object.defineProperty：** Vue3使用Proxy作为响应式系统的实现方式，相比于Vue2中的Object.defineProperty，Proxy具有更好的性能和更丰富的功能。
- **深层响应式：** Vue3的响应式系统支持对嵌套对象和数组的深层响应式，不需要像Vue2中那样手动调用$set方法。

**5. 更好的开发工具支持：**
- **更好的调试体验：** Vue3提供了更好的调试工具支持，使得开发者能够更方便地检查组件状态、事件和属性。
- **更好的性能追踪：** Vue3的开发工具支持性能追踪，可以帮助开发者分析和优化应用的性能问题。

需要注意的是，由于Vue3引入了一些重大改进，与Vue2存在一些不兼容的地方。因此，如果你的项目是基于Vue2开发的，迁移到Vue3可能需要进行一些代码调整和重构。但是，Vue团队提供了一些工具和指南来帮助开发者进行平滑的迁移。

<br/>

### vue 对数组的方法做了重写的操作，如何实现对 vue2 中对数组操作的 push()方法 

公司：高德

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/307)
在Vue2中，对于响应式数组的操作，Vue通过重写数组的原型方法来实现。例如，Vue2会重写数组的`push()`方法，使其在调用`push()`时能够触发视图更新。

在Vue3中，由于使用了Proxy作为响应式系统的实现方式，重写数组的原型方法的方式不再适用。相反，Vue3提供了一些新的API来实现对响应式数组的操作。

要实现在Vue3中对数组进行类似`push()`的操作，可以使用`reactive`函数将数组转换为响应式对象，然后使用`Array`的原生方法进行操作。下面是一个示例：

```javascript
import { reactive } from 'vue';

const state = reactive({
  array: []
});

// 添加元素到数组
state.array.push('item');

console.log(state.array); // ['item']
```

在上面的示例中，我们使用`reactive`函数将`state`对象转换为响应式对象。然后，我们可以直接使用`push()`方法向`state.array`数组中添加元素。由于`state.array`是响应式的，当调用`push()`方法时，Vue会自动追踪数组的变化并更新相关的视图。

需要注意的是，在Vue3中，直接对数组进行索引赋值或使用`length`属性改变数组长度的操作，不会触发视图更新。如果需要手动触发视图更新，可以使用`toRefs`函数将数组转换为响应式引用，然后对引用进行操作。

```javascript
import { reactive, toRefs } from 'vue';

const state = reactive({
  array: []
});

// 将数组转换为响应式引用
const { array } = toRefs(state);

// 添加元素到数组
array.value.push('item');

console.log(array.value); // ['item']
```

在上面的示例中，我们使用`toRefs`函数将`state.array`转换为响应式引用`array`。然后，我们可以通过`array.value`来访问和操作数组。当调用`push()`方法时，Vue会自动追踪数组的变化并更新相关的视图。

总结起来，Vue3中对数组的操作不再需要重写原型方法，而是通过`reactive`函数将数组转换为响应式对象，然后直接使用原生的数组方法进行操作。

<br/>

### 简述 Vue 的基本原理 

公司：脉脉

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/290)
Vue的基本原理可以概括为以下几个方面：

1. **响应式数据绑定：** Vue使用了响应式数据绑定来实现数据和视图的自动同步。当数据发生变化时，视图会自动更新，而无需手动操作DOM。Vue通过使用Object.defineProperty或Proxy来劫持数据对象的属性访问，从而实现对数据的监听和响应。

2. **模板解析和编译：** Vue使用模板来描述视图的结构和内容。在Vue的编译过程中，会将模板解析为抽象语法树（AST），然后将AST转换为渲染函数。渲染函数是一个函数，它返回一个虚拟DOM树（VNode），用于描述视图的结构和内容。

3. **虚拟DOM和渲染：** Vue使用虚拟DOM来表示真实的DOM结构，并通过对比新旧虚拟DOM树的差异，最小化DOM操作，提高性能。当数据发生变化时，Vue会重新渲染虚拟DOM，并通过Diff算法找出需要更新的部分，然后只更新这些部分的真实DOM。

4. **组件化开发：** Vue将应用程序划分为一个个可复用的组件。每个组件包含自己的模板、逻辑和样式。组件可以嵌套使用，形成组件树。Vue通过组件的定义和组件间的通信机制，实现了高度的组件化开发和复用。

5. **生命周期钩子：** Vue提供了一系列的生命周期钩子函数，允许开发者在组件的不同阶段执行自定义的逻辑。例如，可以在组件创建前、创建后、更新前、更新后等时机执行相应的钩子函数。

6. **指令和过滤器：** Vue提供了一些内置的指令（如v-bind、v-if、v-for等）和过滤器，用于在模板中添加特定的行为和逻辑。指令可以用于绑定数据、监听事件、条件渲染等，而过滤器可以用于对数据进行格式化和处理。

7. **事件处理：** Vue提供了一套事件系统，用于处理DOM事件和自定义事件。开发者可以通过v-on指令绑定事件监听器，并在事件触发时执行相应的逻辑。Vue的事件系统支持事件修饰符、按键修饰符、自定义事件等功能。

总的来说，Vue的基本原理是通过响应式数据绑定、模板解析和编译、虚拟DOM和渲染、组件化开发、生命周期钩子、指令和过滤器、事件处理等机制，实现了数据驱动的视图更新和组件化开发的框架。这些机制使得开发者可以更高效、更灵活地构建交互性强、可维护性好的Web应用程序。

<br/>

### 简述 Vue 的生命周期以及每个阶段做的事 

公司：脉脉、58

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/289)
Vue的生命周期可以分为八个阶段，每个阶段都有对应的钩子函数，用于在特定时机执行自定义的逻辑。以下是Vue的生命周期阶段及其对应的钩子函数：

1. **beforeCreate（创建前）：** 在实例初始化之后，数据观测和事件配置之前被调用。此时，实例的数据和方法都还未初始化，无法访问到data、computed、methods等属性。

2. **created（创建后）：** 在实例创建完成后被调用。此时，实例的数据已经初始化，可以访问到data、computed、methods等属性。可以进行一些初始化的操作，如异步请求数据、监听事件等。

3. **beforeMount（挂载前）：** 在挂载开始之前被调用。此时，模板编译已完成，但尚未将模板渲染到页面中。可以在此阶段进行一些DOM操作。

4. **mounted（挂载后）：** 在挂载完成后被调用。此时，模板已经被渲染到页面中，并且可以访问到渲染后的DOM元素。可以进行一些需要DOM的操作，如获取DOM元素、绑定第三方插件等。

5. **beforeUpdate（更新前）：** 在数据更新之前被调用。此时，虚拟DOM已经重新渲染，但尚未应用到页面中。可以在此阶段进行一些更新前的操作，如获取更新前的DOM状态。

6. **updated（更新后）：** 在数据更新完成后被调用。此时，虚拟DOM已经重新渲染，并且更新已经应用到页面中。可以进行一些更新后的操作，如操作更新后的DOM、与其他库进行交互等。

7. **beforeDestroy（销毁前）：** 在实例销毁之前被调用。此时，实例仍然完全可用。可以进行一些销毁前的操作，如清除定时器、解绑事件等。

8. **destroyed（销毁后）：** 在实例销毁之后被调用。此时，实例已经被销毁，所有的事件监听器和子组件也被移除。可以进行一些销毁后的操作，如清理资源、发送统计信息等。

通过在这些钩子函数中编写自定义的逻辑，开发者可以在不同的生命周期阶段进行相应的操作，如初始化数据、发送请求、操作DOM、清理资源等，以满足特定的业务需求。

<br/>

### 说一下 Vue 组件的通信方式都有哪些？(父子组件，兄弟组件，多级嵌套组件等等) 

公司：脉脉、58

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/288)
Vue组件之间的通信方式有以下几种：

1. **父子组件通信：** 父组件可以通过props向子组件传递数据，子组件通过props接收父组件传递的数据。父组件还可以通过监听子组件的事件来获取子组件的状态变化。

2. **子组件向父组件通信：** 子组件可以通过$emit方法触发自定义事件，并传递数据给父组件。父组件通过在子组件上使用v-on指令监听子组件触发的事件，并在对应的方法中处理子组件传递的数据。

3. **兄弟组件通信：** 兄弟组件之间的通信需要借助共同的父组件作为中介。可以通过父组件作为中介，将数据传递给一个兄弟组件，然后再由该兄弟组件传递给另一个兄弟组件。

4. **跨级组件通信：** 跨级组件通信可以使用Vue的插件机制或者事件总线来实现。通过Vue的provide/inject特性，可以在父组件中提供数据，然后在子孙组件中通过inject注入数据。另一种方式是使用事件总线，即创建一个空的Vue实例作为事件中心，任何组件都可以通过该实例的$on和$emit方法进行事件的监听和触发。

5. **Vuex状态管理：** Vuex是Vue官方推荐的状态管理库，用于管理应用中的共享状态。通过在Vuex中定义状态和对应的操作方法，不同组件可以通过调用方法来修改和获取共享状态，实现组件之间的通信。

6. **$refs引用：** Vue组件实例上的$refs属性可以用来访问子组件或DOM元素。父组件可以通过$refs来直接调用子组件的方法或访问子组件的属性。

以上是Vue组件之间常用的通信方式，开发者可以根据具体的场景选择合适的方式来实现组件之间的数据传递和交互。

<br/>

### 说一下 Vuex 的原理以及自己的理解 

公司：脉脉

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/287)
Vuex是Vue.js官方推荐的状态管理库，用于管理Vue应用中的共享状态。它基于Flux架构和Redux思想，提供了一种集中式的、可预测的状态管理方案。

Vuex的核心原理可以概括为以下几点：

1. **单一状态树：** Vuex将应用的所有状态存储在一个单一的状态树中，即store。这个状态树是响应式的，当状态发生变化时，相关的组件会自动更新。

2. **状态是只读的：** Vuex的状态是只读的，唯一改变状态的方式是提交mutation。这样可以确保状态的可追踪性和可维护性。

3. **使用mutation修改状态：** Mutation是Vuex中唯一允许修改状态的方式。Mutation是一个包含type和handler的对象，它定义了如何修改状态。通过提交mutation，可以保证状态的变更是可追踪的，方便调试和维护。

4. **通过Action进行异步操作：** 在处理异步操作时，可以使用Action。Action是一个包含type和handler的对象，它可以包含异步操作和业务逻辑。Action可以提交mutation来修改状态，也可以通过commit方法触发其他Action。

5. **Getter获取状态：** Getter用于从store中获取状态，并可以对状态进行计算和处理。Getter可以接收state作为第一个参数，可以接收其他getter作为第二个参数，可以通过store.getters访问。

6. **模块化管理：** Vuex允许将store分割成模块，每个模块拥有自己的state、mutation、action和getter。这样可以更好地组织和管理大型应用的状态。

通过以上原理，Vuex实现了一个响应式的、可预测的状态管理机制。它能够帮助开发者更好地管理应用的状态，提高代码的可维护性和可测试性。在大型应用中，使用Vuex可以更好地组织和共享状态，简化组件之间的通信，提高开发效率。

<br/>

### Vue v-model 是如何实现的，语法糖实际是什么 

公司：脉脉

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/286)
`v-model` 是 Vue.js 中用于实现双向数据绑定的指令。它是一种语法糖，其实现原理涉及到两个关键部分：**属性绑定**和**事件监听**。

#### 实现原理：

1. **属性绑定（Binding）：** 当一个组件使用 `v-model` 指令时，实际上是在做一种属性的绑定，将父组件传递给子组件的值与子组件内部的值进行绑定。这通常涉及到两个属性：

   - **父组件的值（prop）：** 通过在父组件中使用 `v-model` 绑定一个变量，并给这个变量传递给子组件。
   - **子组件内部的值（value）：** 在子组件中，使用 `props` 接收父组件传递的值，并将其用于初始化子组件内部的状态。

   ```vue
   <!-- 父组件 -->
   <template>
     <ChildComponent v-model="parentValue" />
   </template>

   <script>
   export default {
     data() {
       return {
         parentValue: 'Hello from parent',
       };
     },
   };
   </script>
   ```

   ```vue
   <!-- 子组件 -->
   <template>
     <input :value="value" @input="$emit('input', $event)" />
   </template>

   <script>
   export default {
     props: ['value'],
   };
   </script>
   ```

2. **事件监听（Event Listening）：** 在子组件中，通过 `$emit` 发送名为 `input` 的事件，将用户输入的新值传递给父组件。这个事件会被父组件捕获，从而实现了双向绑定。

   ```vue
   <!-- 子组件 -->
   <template>
     <input :value="value" @input="$emit('input', $event)" />
   </template>
   ```

#### 语法糖：

`v-model` 其实是以下两个常见 Vue 模式的语法糖：

1. **绑定值：** `:value` 和 `@input` 的组合。
   
   ```vue
   <!-- 语法糖 -->
   <input v-model="someValue" />
   
   <!-- 等同于 -->
   <input :value="someValue" @input="someValue = $event" />
   ```

2. **绑定对象：** 当 `v-model` 用于绑定一个对象时，实际上是绑定了对象的某个属性。

   ```vue
   <!-- 语法糖 -->
   <input v-model="obj.prop" />
   
   <!-- 等同于 -->
   <input :value="obj.prop" @input="obj.prop = $event" />
   ```

总体而言，`v-model` 是一种方便的语法糖，简化了双向数据绑定的书写，提高了代码的可读性和可维护性。在实际使用中，理解其背后的属性绑定和事件监听原理有助于更深入地理解 Vue.js 的数据流。
<br/>

### 说一下 Vue dom diff 算法 

公司：网易

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/281)
Vue 的虚拟 DOM diff 算法是用于比较两个虚拟 DOM 树的差异，并最小化对实际 DOM 的操作，从而提高性能。下面详细解释 Vue 的虚拟 DOM diff 算法的工作原理：

1. **生成虚拟 DOM 树：** 在 Vue 中，模板被编译为虚拟 DOM 树，它是一个轻量级的 JavaScript 对象结构，描述了实际 DOM 的层次结构和属性。

2. **比较两个虚拟 DOM 树：** 当数据发生变化时，Vue 会生成一个新的虚拟 DOM 树。然后，Vue 的 diff 算法会比较新旧两个虚拟 DOM 树的差异。

3. **深度优先遍历：** Vue 的 diff 算法采用深度优先遍历的方式进行差异比较。它会逐层比较新旧两个虚拟 DOM 树的节点，并记录下差异。

4. **更新差异节点：** 在比较过程中，当发现差异节点时，Vue 会根据差异类型执行相应的 DOM 操作，以更新实际 DOM。

   - **新增节点：** 如果在新的虚拟 DOM 树中存在而在旧的虚拟 DOM 树中不存在的节点，Vue 会将其添加到实际 DOM 中。
   - **删除节点：** 如果在旧的虚拟 DOM 树中存在而在新的虚拟 DOM 树中不存在的节点，Vue 会将其从实际 DOM 中删除。
   - **更新节点：** 如果一个节点在新旧虚拟 DOM 树中都存在，但它们的属性或子节点发生了变化，Vue 会更新实际 DOM 中的对应节点。

5. **批量更新：** Vue 的 diff 算法会将所有的差异记录下来，并批量执行 DOM 操作，以减少对实际 DOM 的访问次数，提高性能。

通过虚拟 DOM diff 算法，Vue 能够高效地更新实际 DOM，避免了频繁的直接操作 DOM，从而提升了性能和用户体验。但需要注意的是，虚拟 DOM diff 算法也会带来一定的计算开销，因此在某些情况下，手动优化实际 DOM 操作可能会更高效。

<br/>

### 说一下 Vue 的\$nextTick 原理

公司：自如

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/263)
```
$nextTick 主要作用是在 DOM 更新之后执行一段代码

异步更新队列： 当 Vue 实例中的响应式数据发生变化时，Vue 并不会立即更新 DOM。相反，它会把需要更新的操作放入一个队列中，然后通过异步方式在未来的某个时刻执行这些更新操作。

事件循环（Event Loop）： JavaScript 是单线程执行的，它使用事件循环机制来处理异步任务。当主线程执行完同步任务后，会检查异步任务队列，如果有任务就执行。Vue 利用事件循环机制来确保在 DOM 更新之后执行 $nextTick 的回调函数。

$nextTick的实现：当你调用$nextTick(callback)时，Vue 会将这个回调函数放入异步更新队列中。在当前执行栈执行完毕后（即当前代码执行完毕），Vue 会检查是否存在异步更新队列中的任务。如果有，它会等待当前代码执行完成，然后在事件循环的下一个周期执行队列中的任务，这时 $nextTick 中的回调函数就会被调用。

应用场景： $nextTick 主要用于在 DOM 更新之后执行一些操作，比如在数据变化后操作 DOM。由于 Vue 的响应式系统是异步的，所以在数据变化后立即去访问 DOM 通常不会得到预期的结果。使用 $nextTick 可以确保在下次 DOM 更新循环结束之后执行回调，这时 DOM 已经被更新，可以安全地操作 DOM。
```

<br/>

### 说一下 vue-router 的原理

公司：自如

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/262)
Vue Router 是 Vue.js 官方的路由管理器，用于实现单页面应用（SPA）中的路由功能。它基于 Vue 的组件系统，通过监听 URL 的变化，动态地渲染组件，实现页面的切换和导航。下面详细解释 Vue Router 的原理和工作方式：

1. **路由配置：** 在 Vue Router 中，我们需要定义路由配置，即指定 URL 和对应的组件之间的映射关系。这些配置通常是在一个 JavaScript 对象中进行定义。

2. **路由实例化：** 在 Vue 应用的入口处，我们需要实例化一个 Vue Router 对象，并将路由配置传递给它。这样 Vue Router 就知道如何根据 URL 渲染对应的组件。

3. **路由匹配：** 当用户访问一个 URL 时，Vue Router 会根据路由配置进行匹配，找到与当前 URL 匹配的路由规则。匹配过程通常是基于 URL 的路径和参数进行的。

4. **组件渲染：** 一旦找到匹配的路由规则，Vue Router 就会根据规则中指定的组件，动态地渲染对应的组件。这个过程通常是通过 Vue 的动态组件来实现的。

5. **URL 变化监听：** Vue Router 会监听 URL 的变化，当用户在应用中进行导航时，它会根据新的 URL 进行路由匹配和组件渲染。这样就实现了 SPA 中的页面切换和导航功能。

6. **导航守卫：** Vue Router 还提供了导航守卫的功能，允许我们在路由切换前后执行一些逻辑。例如，可以在路由切换前检查用户是否有权限访问某个页面，或者在路由切换后执行一些统计操作。

7. **路由参数和查询参数：** Vue Router 支持路由参数和查询参数的传递。路由参数是 URL 中的一部分，用于标识唯一的资源，而查询参数是以 `?` 开头的键值对，用于传递额外的信息。

通过以上的原理和工作方式，Vue Router 实现了前端路由的功能，使得我们可以在单页面应用中实现页面的切换和导航，提供了更好的用户体验和交互性。

<br/>

### Vue 是如何收集依赖的 

公司：自如

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/259)
在 Vue.js 中，依赖收集是实现响应式系统的关键机制之一。Vue 通过依赖收集来追踪数据与视图之间的关系，当数据发生变化时，能够自动更新相关的视图。下面详细解释 Vue 是如何收集依赖的：

1. **Observer 观察者模式：** Vue 使用了观察者模式来实现数据的响应式。在 Vue 初始化时，会对数据对象进行递归遍历，将每个属性转换为响应式的 getter 和 setter。当访问属性时，会触发 getter，用于收集依赖。

2. **Dep 依赖管理：** Vue 中的 Dep（Dependency）是一个依赖管理器，它用于存储和管理依赖关系。每个响应式属性都会有一个对应的 Dep 实例。Dep 实例内部维护了一个存储依赖的数组，以及一些用于添加和删除依赖的方法。

3. **Watcher 观察者：** Watcher 是一个观察者对象，它用于订阅数据的变化。在 Vue 中，每个组件实例都会有一个对应的 Watcher 对象。当组件渲染时，会创建一个 Watcher 对象，并将其与当前组件实例关联起来。

4. **依赖收集过程：** 当组件渲染时，会执行模板中的代码，访问响应式属性。在访问属性的过程中，会触发属性的 getter 方法。Getter 方法会将当前的 Watcher 对象添加到对应属性的 Dep 实例中。

5. **更新触发：** 当数据发生变化时，会触发属性的 setter 方法。Setter 方法会通知 Dep 实例，然后 Dep 实例会遍历存储的所有 Watcher 对象，并调用其 update 方法。

6. **更新过程：** Watcher 的 update 方法会触发组件的重新渲染。Vue 会执行组件的 render 函数，生成新的虚拟 DOM，并与旧的虚拟 DOM 进行对比，找出需要更新的部分，然后进行局部更新。

通过以上的依赖收集过程，Vue 能够追踪数据与视图之间的依赖关系，并在数据发生变化时自动更新相关的视图。这样就实现了响应式的数据绑定，使得开发者能够更方便地编写和维护复杂的前端应用。

<br/>

### 说一下 Vue 单页与多页的区别 

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/412)
Vue 单页应用（Single-Page Application，SPA）和多页应用（Multiple-Page Application，MPA）是两种不同的前端应用架构方式，它们在页面加载、路由管理、性能等方面有一些区别。下面详细解释 Vue 单页与多页的区别：

**1. 页面加载方式：**
- 单页应用：SPA 只有一个 HTML 页面，所有的内容都在这个页面中动态加载和更新。初始时只需加载一次 HTML、CSS 和 JavaScript 文件，后续的页面切换通过 AJAX 或路由来实现，只更新部分页面内容。
- 多页应用：MPA 每个页面都是一个独立的 HTML 页面，每次页面切换都需要重新加载整个页面，包括 HTML、CSS 和 JavaScript 文件。

**2. 路由管理：**
- 单页应用：SPA 使用前端路由来管理页面的切换和导航，通过改变 URL 的 hash 或使用 HTML5 的 History API 来实现。路由切换时，只需要更新部分页面内容，不会重新加载整个页面。
- 多页应用：MPA 使用传统的后端路由来管理页面的切换和导航，每次页面切换都需要向服务器发送请求，服务器返回对应的 HTML 页面。

**3. 用户体验：**
- 单页应用：SPA 提供了更流畅的用户体验，页面切换快速，无需等待整个页面加载。同时，SPA 可以实现无刷新的局部更新，用户感知不到页面的刷新。
- 多页应用：MPA 页面切换时需要重新加载整个页面，会有一定的加载时间，用户体验相对较差。

**4. 性能优化：**
- 单页应用：SPA 在初始加载时需要下载较大的 JavaScript 文件，但后续的页面切换只需要加载数据，不需要重新下载 JavaScript 文件，减少了网络请求和服务器压力。
- 多页应用：MPA 每次页面切换都需要重新加载整个页面，包括 JavaScript 文件，会增加网络请求和服务器压力。

**5. 开发复杂度：**
- 单页应用：SPA 的开发相对复杂，需要处理前端路由、状态管理等问题。但一旦搭建好基础架构，后续的开发会更加高效。
- 多页应用：MPA 的开发相对简单，每个页面都是独立的，开发者可以更专注于单个页面的开发。但对于共享的组件和逻辑，需要进行重复的开发和维护。

综上所述，SPA 和 MPA 在页面加载、路由管理、用户体验、性能优化和开发复杂度等方面有一些区别。选择哪种架构方式取决于具体的项目需求和开发团队的技术栈。SPA 适用于需要较好用户体验和较高性能的应用，而 MPA 则适用于传统的多页面应用。
<br/>

### 说一下 Vue 路由实现原理 

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/411)
Vue 路由的实现原理主要基于 Vue Router 插件。Vue Router 是 Vue.js 官方提供的路由管理器，它通过监听 URL 的变化，根据配置的路由规则，动态地渲染组件，实现了前端路由的功能。下面详细解释 Vue 路由的实现原理：

**1. 路由配置：**
在 Vue Router 中，我们需要先定义路由配置。路由配置是一个包含路径和对应组件的映射关系的对象。可以通过配置文件或者直接在代码中定义路由配置。

**2. 路由实例化：**
在 Vue 应用的入口文件中，我们需要实例化 Vue Router，并将路由配置传入。这样 Vue Router 就会根据配置生成一个路由实例。

**3. 路由视图容器：**
在 Vue 应用的模板中，需要提供一个容器用于显示路由对应的组件。通常使用 `<router-view>` 标签作为路由视图容器，它会根据当前 URL 的路径匹配到对应的组件，并将其渲染到容器中。

**4. 路由导航：**
当用户点击页面中的链接或者通过编程方式切换路由时，Vue Router 会捕获到这个事件，并根据配置的路由规则进行匹配。匹配到对应的路由后，会触发路由导航的过程。

**5. 路由导航守卫：**
在路由导航过程中，Vue Router 提供了一些导航守卫的钩子函数，可以在路由切换前后执行一些逻辑。例如，可以在路由切换前检查用户是否登录，或者在路由切换后进行一些页面的初始化操作。

**6. 组件渲染：**
当路由导航完成后，Vue Router 会根据匹配到的路由配置，找到对应的组件。然后，将这个组件渲染到路由视图容器中，完成页面的切换。

**7. URL 更新：**
在路由导航完成后，Vue Router 会根据匹配到的路由配置，更新浏览器的 URL。这样，用户可以通过浏览器的前进、后退按钮来切换路由。

总结来说，Vue 路由的实现原理是通过监听 URL 的变化，根据配置的路由规则，动态地渲染组件，并提供了导航守卫等功能来控制路由的切换行为。这样就实现了前端路由的功能，使得单页应用可以像多页应用一样进行页面切换。

<br/>

### Vue3.0 为什么要用 proxy？是怎么用 proxy 实现数据监听的? 

公司：虎扑、CVTE

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/396)
在 Vue 3.0 中，Vue 的响应式系统进行了重大改进，其中的一个主要改动就是引入了 ECMAScript 6 中的 Proxy 对象，代替了 Vue 2.x 中使用的 Object.defineProperty 方法。使用 Proxy 的主要原因是它提供了更好的性能和更强大的功能，使得 Vue 3.0 的响应式系统更加灵活和高效。

### 为什么使用 Proxy？

1. **性能提升：** Proxy 比 Object.defineProperty 更高效，因为 Proxy 可以直接代理整个对象，而不是像 Object.defineProperty 那样需要遍历对象的每个属性进行劫持。

2. **更灵活的API：** Proxy 提供了丰富的钩子函数，可以实现更复杂的响应式逻辑，而 Object.defineProperty 只能监听属性的读取和赋值操作。

3. **更好的嵌套支持：** Proxy 可以监听对象的深层嵌套，而 Object.defineProperty 需要递归处理嵌套对象。

### 如何使用 Proxy 实现数据监听？

在 Vue 3.0 中，使用 Proxy 实现数据监听非常简单。以下是一个简单的示例：

```javascript
// 创建一个响应式对象
const reactiveData = new Proxy({
  name: 'Vue',
  age: 3
}, {
  // 钩子函数：当尝试读取 reactiveData 对象的属性时触发
  get(target, key, receiver) {
    console.log(`访问了属性：${key}`);
    return Reflect.get(target, key, receiver);
  },
  // 钩子函数：当尝试设置 reactiveData 对象的属性时触发
  set(target, key, value, receiver) {
    console.log(`设置了属性：${key}，新值为：${value}`);
    return Reflect.set(target, key, value, receiver);
  }
});

console.log(reactiveData.name); // 访问了属性：name，输出：Vue
reactiveData.age = 4; // 设置了属性：age，新值为：4
```

在上面的示例中，我们创建了一个名为 `reactiveData` 的对象，并使用 Proxy 对其进行代理。Proxy 的第二个参数是一个配置对象，其中的 `get` 钩子函数会在读取属性时触发，`set` 钩子函数会在设置属性时触发。这样，我们就可以在属性被访问和修改时执行自定义的逻辑。

在 Vue 3.0 中，Vue 的响应式系统内部就是使用类似的方式，利用 Proxy 对象实现了数据的监听和更新。这种方式比 Vue 2.x 中的 Object.defineProperty 更高效和灵活，为 Vue 的性能和开发体验提供了显著的提升。 Vue 3.0 中，Vue 的响应式系统进行了重大改进，其中的一个主要改动就是引入了 ECMAScript 6 中的 Proxy 对象，代替了 Vue 2.x 中使用的 Object.defineProperty 方法。使用 Proxy 的主要原因是它提供了更好的性能和更强大的功能，使得 Vue 3.0 的响应式系统更加灵活和高效。

### 为什么使用 Proxy？

1. **性能提升：** Proxy 比 Object.defineProperty 更高效，因为 Proxy 可以直接代理整个对象，而不是像 Object.defineProperty 那样需要遍历对象的每个属性进行劫持。

2. **更灵活的API：** Proxy 提供了丰富的钩子函数，可以实现更复杂的响应式逻辑，而 Object.defineProperty 只能监听属性的读取和赋值操作。

3. **更好的嵌套支持：** Proxy 可以监听对象的深层嵌套，而 Object.defineProperty 需要递归处理嵌套对象。

### 如何使用 Proxy 实现数据监听？

在 Vue 3.0 中，使用 Proxy 实现数据监听非常简单。以下是一个简单的示例：

```javascript
// 创建一个响应式对象
const reactiveData = new Proxy({
  name: 'Vue',
  age: 3
}, {
  // 钩子函数：当尝试读取 reactiveData 对象的属性时触发
  get(target, key, receiver) {
    console.log(`访问了属性：${key}`);
    return Reflect.get(target, key, receiver);
  },
  // 钩子函数：当尝试设置 reactiveData 对象的属性时触发
  set(target, key, value, receiver) {
    console.log(`设置了属性：${key}，新值为：${value}`);
    return Reflect.set(target, key, value, receiver);
  }
});

console.log(reactiveData.name); // 访问了属性：name，输出：Vue
reactiveData.age = 4; // 设置了属性：age，新值为：4
```

在上面的示例中，我们创建了一个名为 `reactiveData` 的对象，并使用 Proxy 对其进行代理。Proxy 的第二个参数是一个配置对象，其中的 `get` 钩子函数会在读取属性时触发，`set` 钩子函数会在设置属性时触发。这样，我们就可以在属性被访问和修改时执行自定义的逻辑。

在 Vue 3.0 中，Vue 的响应式系统内部就是使用类似的方式，利用 Proxy 对象实现了数据的监听和更新。这种方式比 Vue 2.x 中的 Object.defineProperty 更高效和灵活，为 Vue 的性能和开发体验提供了显著的提升。

<br/>

### 说一下对 vue3.0 的了解，vue3.0 为什么要用代理 

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/577)
Vue 3.0 是 Vue.js 的下一个主要版本，经历了一些重大变化和改进，其中一个显著的改变是引入了代理（Proxy）作为其响应式系统的核心。让我详细解释一下为什么 Vue 3.0 使用代理。

1. 更高效的响应式系统：
   Vue 2.x 使用了 Object.defineProperty 这个 ES5 特性来实现响应式数据。这种方法有一些限制，比如不能监听数组的变化，需要遍历对象属性并逐个设置 getter 和 setter。这导致了性能上的一些问题，尤其是在大型应用中。Vue 3.0 切换到了 Proxy，它提供了更直观和高效的拦截对象操作的方式，能够更准确地捕获属性的变化，同时支持监听数组的变化，这使得 Vue 3.0 的响应式系统更快和更可靠。

2. 更灵活的拦截器：
   Proxies 提供了一种更灵活的方式来拦截对象上的各种操作，包括读取、写入、删除属性等。这允许 Vue 3.0 在数据变化时执行更精确的更新，而不必依赖 getter 和 setter。这种灵活性使得 Vue 3.0 能够更好地支持许多高级特性，例如动态添加属性、嵌套属性等。

3. 更好的 TypeScript 支持：
   使用代理使得 Vue 3.0 在 TypeScript 中的类型推断更加强大和准确。Vue 3.0 的代码库本身也是使用 TypeScript 编写的，这意味着类型提示更丰富，开发者能够更轻松地使用 TypeScript 来构建 Vue 应用。

4. 更小的体积：
   由于代理的自然方式来拦截对象操作，Vue 3.0 的核心代码变得更加简洁和紧凑，这导致了更小的包体积，使得 Vue 3.0 更适合移动应用和性能要求较高的场景。

总的来说，代理（Proxy）的引入使得 Vue 3.0 的响应式系统更加高效、灵活、可维护，同时也带来了更好的类型支持和更小的体积。这些改进使得 Vue 3.0 成为一个更强大、现代化的前端框架。

<br/>

### 子组件可以直接改变父组件的数据么，说明原因 

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/576)
在 Vue 中，子组件不能直接改变父组件的数据。这是因为 Vue 遵循了单向数据流的原则，父组件通过 props 将数据传递给子组件，子组件可以读取这些数据并进行展示，但不能直接修改父组件的数据。

这种设计有以下几个原因：

1. 数据流清晰：单向数据流使得数据的流向更加清晰明确。父组件作为数据的源头，通过 props 将数据传递给子组件，子组件只能读取这些数据，这样可以更容易追踪数据的来源和变化。

2. 组件解耦：父组件和子组件是相互独立的，它们应该尽量解耦，减少相互依赖。如果子组件可以直接修改父组件的数据，那么子组件就会对父组件产生依赖，增加了组件之间的耦合性，使得代码更难以维护和理解。

3. 数据一致性：通过限制子组件对父组件数据的修改，可以确保数据的一致性。如果多个子组件都可以直接修改父组件的数据，那么很容易出现数据的不一致性，导致应用的状态变得不可预测。

然而，如果需要在子组件中修改父组件的数据，可以通过在子组件中触发自定义事件，然后由父组件监听该事件并在事件处理函数中修改数据。这样可以保持数据流的单向性，同时实现子组件对父组件数据的间接修改。另外，Vue 还提供了一些高级的状态管理方案，如 Vuex，可以更好地管理组件之间的共享状态。

<br/>

### Vue 中一次性 200 条弹幕怎么处理 

公司：58

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/458)
处理大量弹幕消息的情况，特别是一次性展示200条弹幕，需要考虑性能和用户体验。以下是一种处理方法，包括前端和后端的考虑：

前端处理：
1. 虚拟滚动：如果要一次性展示200条弹幕，可以使用虚拟滚动技术，只渲染可见区域内的弹幕，而不是将所有200条都同时渲染在页面上。这可以减小渲染负担，提高页面性能。

2. 异步加载：将弹幕数据分批异步加载，每次加载一小部分，然后逐渐添加到展示区域。这可以降低初始加载时的压力，减少页面卡顿。

3. 动画效果：为弹幕添加适度的动画效果，如渐隐、从不同方向飘入等，以增加用户体验。但要注意不要过度使用动画，以免影响性能。

4. 消息过滤：对弹幕消息进行过滤，只展示最重要或最新的消息。可以考虑使用时间戳或其他标志来决定展示哪些消息。

后端处理：
1. 数据传输优化：尽量减小弹幕数据的体积，可以使用压缩算法或二进制格式传输数据，减少网络传输的负担。

2. 数据存储策略：对于弹幕数据的存储，可以采用合适的数据库和索引策略，以快速检索和传输数据。

3. 防滥用：实现合适的用户权限和限制机制，以防止滥用和垃圾弹幕的出现。

4. 服务器负载均衡：考虑服务器负载均衡，以确保服务器能够处理大量并发请求。

5. 异步推送：使用异步消息队列等技术，将弹幕消息推送到前端，以降低服务器的实时压力。

总的来说，处理大量弹幕消息需要前后端协同工作，采用虚拟滚动、异步加载、数据过滤、性能优化等方法来提高用户体验，同时确保后端能够处理大规模的消息传输和存储。这可以确保应用能够高效地处理200条弹幕消息的展示。

<br/>

### vue hooks 有哪些 

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/705)
在 Vue 3 中，引入了 Composition API，它提供了一组新的函数式 API，也被称为 Vue Hooks。这些 Hooks 可以在组件中使用，以实现更灵活和可复用的逻辑。以下是一些常用的 Vue Hooks：

1. `setup`：`setup` 函数是 Composition API 的入口点，它是一个在组件创建之前执行的函数。可以在 `setup` 函数中使用其他 Vue Hooks 来定义组件的逻辑。`setup` 函数接收两个参数：`props` 和 `context`，可以通过解构赋值的方式获取它们。

2. `ref`：`ref` 函数用于创建一个响应式的数据引用。可以将普通的 JavaScript 值包装在 `ref` 函数中，使其成为响应式的。使用 `ref` 创建的变量需要通过 `.value` 来访问和修改。

3. `reactive`：`reactive` 函数用于创建一个响应式的对象。可以将普通的 JavaScript 对象包装在 `reactive` 函数中，使其成为响应式的。使用 `reactive` 创建的对象可以直接访问和修改属性。

4. `computed`：`computed` 函数用于创建一个计算属性。可以将一个 getter 函数传递给 `computed` 函数，它会返回一个计算属性的响应式引用。计算属性会根据它所依赖的响应式数据自动更新。

5. `watch`：`watch` 函数用于监听一个响应式数据的变化。可以传递一个回调函数给 `watch` 函数，当被监听的数据发生变化时，回调函数会被触发。还可以通过配置选项来控制何时触发回调函数。

6. `onMounted`：`onMounted` 函数用于在组件挂载到 DOM 后执行一些操作。可以在 `setup` 函数中使用 `onMounted` 函数，并传递一个回调函数，该回调函数会在组件挂载后被调用。

7. `onUpdated`：`onUpdated` 函数用于在组件更新后执行一些操作。可以在 `setup` 函数中使用 `onUpdated` 函数，并传递一个回调函数，该回调函数会在组件更新后被调用。

8. `onUnmounted`：`onUnmounted` 函数用于在组件卸载前执行一些操作。可以在 `setup` 函数中使用 `onUnmounted` 函数，并传递一个回调函数，该回调函数会在组件卸载前被调用。

这些是常用的 Vue Hooks，它们可以帮助我们更好地组织和复用组件逻辑。使用 Vue Hooks 可以使代码更具可读性、可维护性和可测试性。

<br/>

### 介绍 Vue template 到 render 的过程 

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/704)
Vue.js 允许你使用模板（template）或渲染函数（render function）来创建用户界面。下面详细介绍 Vue 的模板到渲染的过程：

1. **模板（Template）**：
   - **编写模板**：首先，你会编写一个 Vue 组件的模板。模板通常是一个包含 HTML 和 Vue 模板语法的字符串。在模板中，你可以定义组件的结构和数据绑定方式。Vue 模板语法允许你在模板中嵌入表达式、指令和事件处理函数。

   - **编译阶段**：当 Vue 应用启动时，Vue 会将模板编译成渲染函数。这个编译阶段会将模板解析成虚拟 DOM（Virtual DOM）对象，这是一个轻量级的 JavaScript 表示组件的树结构。

2. **渲染函数（Render Function）**：
   - **虚拟 DOM**：编译后的模板变成了虚拟 DOM 对象。虚拟 DOM 是一个以 JavaScript 对象的形式表示的组件结构，它包含了组件的层次结构、属性、指令等信息。

   - **渲染函数的生成**：Vue 将虚拟 DOM 转化成渲染函数。这个渲染函数是一个 JavaScript 函数，接收一个参数，称为 `h`，它用于创建虚拟 DOM 元素。

   - **实际渲染**：当组件需要渲染时，Vue 调用渲染函数并传递 `h` 函数。渲染函数会根据组件的当前状态和数据，调用 `h` 函数来创建虚拟 DOM 元素。这些虚拟 DOM 元素描述了组件的最新状态。

   - **更新虚拟 DOM**：如果组件的状态或数据发生变化，渲染函数将再次执行，以创建更新后的虚拟 DOM。Vue 会将新旧虚拟 DOM 进行比较，以确定需要更新的部分。

   - **实际 DOM 更新**：最终，Vue 将根据新的虚拟 DOM 更新实际的 DOM。这个过程是高效的，因为 Vue 会尽量只更新变化的部分，而不是重新渲染整个组件。

总的来说，Vue 的模板到渲染的过程包括编写模板、模板编译成虚拟 DOM、虚拟 DOM 转化成渲染函数、根据数据创建虚拟 DOM 元素，然后将实际 DOM 更新为新的虚拟 DOM。这个过程使 Vue 具有高效的响应式更新机制，以确保用户界面的实时变化。

<br/>

### 怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？

公司：会小二

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/690)
在 Vue.js 中，可以使用 Vue Router 来实现动态路由。下面是关于定义动态路由和获取传递的动态参数的详细步骤：

1. **定义动态路由**：
   - 在 Vue Router 的路由配置中，使用冒号（:）来定义动态路由参数。例如，`/user/:id` 中的 `:id` 就是一个动态路由参数，表示用户的 ID。
   - 在路由配置中，将动态参数作为路由路径的一部分。例如：
     ```javascript
     const routes = [
       {
         path: '/user/:id',
         component: User
       }
     ];
     ```

2. **获取传递的动态参数**：
   - 在组件中，可以通过 `$route` 对象来获取传递的动态参数。`$route.params` 对象包含了所有的动态参数。
   - 在上述的例子中，可以在 `User` 组件中通过 `$route.params.id` 来获取传递的用户 ID。

   - 你可以在组件的生命周期钩子函数（如 `created`、`mounted` 等）中访问 `$route.params` 对象来获取动态参数。例如：
     ```javascript
     export default {
       created() {
         const userId = this.$route.params.id;
         // 使用动态参数进行相应的操作
       }
     }
     ```

   - 如果路由参数发生变化，组件会重新渲染，并且可以通过 `$route` 对象再次获取最新的动态参数。

总结起来，要定义动态路由，需要在路由配置中使用冒号（:）来定义动态参数。要获取传递的动态参数，可以通过 `$route.params` 对象来访问。在组件中，可以在生命周期钩子函数或其他需要的地方使用 `$route.params` 来获取动态参数，并进行相应的操作。

<br/>

### 下面关于 Vue 说法正确的是？(单选题) 

```js
A.data 中某一属性的值发生改变后，视图会立即同步进行重新渲染
B.Vue 实例创建后再添加的属性，该属性改动将不会触发视图更新
C.计算属性只有在它的相关依赖发生改变时才会重新求值
D.Vue 组件的 data 选项必须是函数
```

公司：会小二

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/684)
D. Vue 组件的 data 选项必须是函数

详细回答：
在 Vue 组件中，data 选项用于定义组件的数据。根据 Vue 的官方文档，data 选项可以是一个函数，而不是一个对象。这是因为组件可能会被多次复用，如果 data 是一个对象，那么所有复用该组件的实例将共享同一个数据对象，导致数据状态混乱。

因此，正确的做法是将 data 选项定义为一个返回一个新对象的函数。每个组件实例都会调用该函数来获取独立的数据对象，确保每个实例都有自己的数据副本，互不干扰。

例如，一个使用函数定义 data 选项的组件示例：
```javascript
Vue.component('my-component', {
  data() {
    return {
      message: 'Hello, Vue!'
    };
  }
});
```

这样，每个 `my-component` 实例都会有自己独立的 `message` 数据，对其中一个实例的数据进行修改不会影响其他实例。

所以，选项 D 正确，Vue 组件的 data 选项必须是函数。

<br/>

### 为什么要用 Vuex 或者 Redux，不要说为了保存状态 

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/663)
使用 Vuex（对于 Vue.js 应用）或 Redux（对于 React 应用）的目的不仅仅是为了保存状态，而是为了更好地管理应用的状态和数据流。以下是详细回答为什么要使用这些状态管理工具：

1. **单一数据源**：Vuex 和 Redux 引入了单一数据源的概念，即整个应用的状态被存储在一个统一的地方。这使得应用的状态变得可预测和易于调试。你可以轻松追踪应用状态的变化，因为它们都来自同一个数据源。

2. **分离状态和视图**：这些工具鼓励你将应用的状态从组件中分离出来。状态存储在中心化的存储中，而组件则变得更专注于渲染和用户交互。这有助于保持应用的可维护性，可测试性和可扩展性。

3. **数据共享和通信**：在大型应用中，多个组件可能需要共享相同的状态数据，或者需要相互通信。Vuex 和 Redux 提供了一种标准的方式来处理这些情况。组件可以通过派发操作（dispatch）来改变状态，而不需要直接操作状态。这种方式简化了数据流，减少了潜在的数据冲突和错误。

4. **中间件和副作用管理**：这些工具允许你使用中间件来处理副作用，例如异步操作、日志记录、路由导航等。中间件提供了一种非常灵活的方式来管理应用中的副作用，而不需要将其散布在各个组件中。

5. **时间旅行和调试**：由于状态的单一来源和可预测性，这些工具通常提供了强大的调试工具。你可以回溯到先前的状态，甚至能够记录和重放应用状态的变化。这对于调试和解决问题非常有帮助。

6. **更好的组织和结构**：使用 Vuex 或 Redux 通常迫使开发者遵循一定的结构和约定，这有助于更好地组织和维护应用的代码。你知道在哪里查找和修改状态，这种一致性有助于团队协作和维护。

综上所述，Vuex 和 Redux 不仅用于保存状态，而是用于更好地组织、管理和维护应用的状态和数据流。它们提供了一种可维护性和可扩展性更强的方式来构建大型和复杂的应用。

<br/>

### 为什么 Vue data 必须是函数 

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/662)
Vue 中要求将组件的 `data` 选项定义为一个函数的主要原因是为了处理组件复用时数据共享和独立性的问题。以下是详细的解释为什么 Vue 中的 `data` 必须是函数：

1. **数据共享和独立性**：在 Vue 中，组件是可以被复用的，而且通常一个组件可以在应用中多次使用。如果 `data` 是一个对象，而不是一个函数，那么每个组件实例都将共享相同的数据对象。这会导致一个严重的问题：一个组件的状态改变会影响到其他使用相同数据对象的组件，破坏了组件的独立性。通过将 `data` 定义为一个函数，每个组件实例都会调用该函数来获取一个独立的数据对象，确保了组件之间的数据独立性。

2. **可维护性**：将 `data` 定义为一个函数使代码更容易维护。因为每个组件都有自己的数据对象，修改组件内的数据不会意外地影响其他组件。这提高了代码的可维护性，降低了出现潜在错误的风险。

3. **预测性**：通过强制将 `data` 定义为函数，Vue 提供了一种一致的方式来处理数据。无论你在哪个组件中查看 `data`，它都将是一个函数，这种一致性提供了更好的可预测性。

示例：
```javascript
Vue.component('my-component', {
  data() {
    return {
      message: 'Hello, Vue!'
    };
  }
});
```

在上述示例中，`data` 选项是一个返回包含数据的函数。每个 `my-component` 实例都会调用这个函数来获取独立的数据对象，确保了数据的独立性和可预测性。这是为了确保在组件间的数据交互和复用时，不会出现潜在的问题。

<br/>

### Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/658)
在 Vue 中，当 `data` 中某个属性的值发生改变时，视图不会立即同步执行重新渲染。Vue 使用了异步的更新机制来优化性能，即将多个数据变化的更新合并为一次更新，以减少不必要的重绘和重新渲染。

具体来说，当你修改 `data` 中的某个属性时，Vue 会将这个变化记录下来，并将其添加到一个队列中。然后，Vue 会在下一个事件循环中，对队列中的变化进行批量处理，进行一次性的视图更新。

这种异步更新机制的好处是避免了频繁的重绘和重新渲染，提高了性能。例如，如果在同一个事件循环中连续修改了多个属性，Vue 会将这些变化合并为一次更新，只触发一次视图重新渲染，而不是每次属性变化都进行一次渲染。

这种异步更新机制也意味着，如果你在修改数据后立即访问 DOM，你可能会得到之前的 DOM 状态，因为视图尚未更新。如果你需要在数据变化后执行一些操作，可以使用 Vue 提供的 `$nextTick` 方法或在生命周期钩子函数中进行操作，以确保在视图更新后执行。

示例：
```javascript
new Vue({
  data() {
    return {
      message: 'Hello, Vue!'
    };
  },
  methods: {
    updateMessage() {
      this.message = 'Updated message';
      console.log(this.$el.textContent); // 输出 'Hello, Vue!'，因为视图尚未更新
      this.$nextTick(() => {
        console.log(this.$el.textContent); // 输出 'Updated message'，在视图更新后执行
      });
    }
  }
});
```

总结起来，Vue 使用异步的更新机制来优化性能，将多个数据变化合并为一次更新，以减少不必要的重绘和重新渲染。这意味着在修改 `data` 中的属性后，视图不会立即同步执行重新渲染，而是在下一个事件循环中进行一次性的更新。如果需要在数据变化后执行一些操作，可以使用 `$nextTick` 方法或在生命周期钩子函数中进行操作。

<br/>

### 简述 mixin、extends 的覆盖逻辑 

公司：58

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/654)
在 Vue 中，`mixin` 和 `extends` 都是用于组件的复用和扩展的机制。它们可以让我们在多个组件之间共享和重用代码。下面详细解释一下它们的覆盖逻辑：

**Mixin 覆盖逻辑：**
当一个组件使用了多个 mixin，并且这些 mixin 中有相同的选项（如 `data`、`methods`、`computed` 等），Vue 会按照一定的规则进行选项的合并和覆盖。

- 对于 `data`，Vue 会将所有的 `data` 合并成一个新的对象。如果有重复的属性名，后面的 mixin 中的属性会覆盖前面的。
- 对于 `methods`、`computed`、`watch` 等方法，Vue 会将它们合并成一个新的对象。如果有重复的方法名，后面的 mixin 中的方法会覆盖前面的。
- 对于生命周期钩子函数，Vue 会按照一定的顺序依次调用它们。先调用 mixin 中的钩子函数，然后再调用组件自身的钩子函数。

示例：
```javascript
const mixinA = {
  data() {
    return {
      message: 'Mixin A'
    };
  },
  methods: {
    greet() {
      console.log('Hello from Mixin A');
    }
  }
};

const mixinB = {
  data() {
    return {
      message: 'Mixin B'
    };
  },
  methods: {
    greet() {
      console.log('Hello from Mixin B');
    }
  }
};

new Vue({
  mixins: [mixinA, mixinB],
  data() {
    return {
      message: 'Component'
    };
  },
  methods: {
    greet() {
      console.log('Hello from Component');
    }
  },
  created() {
    console.log(this.message); // 输出 'Component'，因为组件自身的 data 覆盖了 mixin 中的 data
    this.greet(); // 输出 'Hello from Component'，因为组件自身的方法覆盖了 mixin 中的方法
  }
});
```

**Extends 覆盖逻辑：**
`extends` 是通过继承方式来扩展一个组件，它会创建一个新的组件，继承自父组件，并可以对父组件的选项进行覆盖和扩展。

- 对于 `data`，如果子组件和父组件都定义了相同的属性名，子组件的属性会覆盖父组件的属性。
- 对于 `methods`、`computed`、`watch` 等方法，子组件会继承父组件的方法，并且可以在子组件中对这些方法进行覆盖或扩展。
- 对于生命周期钩子函数，子组件会继承父组件的钩子函数，并且可以在子组件中对这些钩子函数进行覆盖或扩展。

示例：
```javascript
const ParentComponent = {
  data() {
    return {
      message: 'Parent Component'
    };
  },
  methods: {
    greet() {
      console.log('Hello from Parent Component');
    }
  },
  created() {
    console.log(this.message); // 输出 'Parent Component'
    this.greet(); // 输出 'Hello from Parent Component'
  }
};

const ChildComponent = Vue.extend({
  data() {
    return {
      message: 'Child Component'
    };
  },
  methods: {
    greet() {
      console.log('Hello from Child Component');
    }
  },
  created() {
    console.log(this.message); // 输出 'Child Component'，子组件的 data 覆盖了父组件的 data
    this.greet(); // 输出 'Hello from Child Component'，子组件的方法覆盖了父组件的方法
  }
});

new ChildComponent();
```

总结起来，`mixin` 和 `extends` 都可以用于组件的复用和扩展。在使用多个 mixin 时，Vue 会按照一定的规则进行选项的合并和覆盖。而通过 `extends` 创建的子组件，可以继承父组件的选项，并可以对选项进行覆盖和扩展。这些机制让我们能够更灵活地复用和扩展组件的代码。

<br/>

### Vue 子组件和父组件执行顺序 

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/653)
在Vue中，子组件和父组件之间的执行顺序涉及到生命周期钩子函数的调用以及数据传递的流程。以下是详细的执行顺序：

1. **父组件的`beforeCreate`和`created`钩子函数：**
   - 在父组件创建之前，会触发`beforeCreate`钩子函数。在这个阶段，父组件的实例已经创建，但是数据和事件还没有初始化。
   - 紧接着触发`created`钩子函数，此时父组件的数据和事件已经初始化完成。

2. **父组件的模板渲染：**
   - 父组件的模板开始渲染，包括插入子组件的占位符。

3. **子组件的`beforeCreate`和`created`钩子函数：**
   - 在子组件创建之前，会触发`beforeCreate`钩子函数。在这个阶段，子组件的实例已经创建，但是数据和事件还没有初始化。
   - 紧接着触发`created`钩子函数，此时子组件的数据和事件已经初始化完成。

4. **子组件的模板渲染：**
   - 子组件的模板开始渲染，子组件的数据和事件可以在模板中使用。

5. **父组件的`beforeMount`和`mounted`钩子函数：**
   - 在父组件的模板渲染完成后，会触发`beforeMount`钩子函数。此时，父组件的模板已经编译完成，但还没有挂载到DOM。
   - 紧接着触发`mounted`钩子函数，此时父组件的模板已经挂载到DOM，可以进行DOM操作。

6. **子组件的`beforeMount`和`mounted`钩子函数：**
   - 在子组件的模板渲染完成后，会触发`beforeMount`钩子函数。此时，子组件的模板已经编译完成，但还没有挂载到DOM。
   - 紧接着触发`mounted`钩子函数，此时子组件的模板已经挂载到DOM，可以进行DOM操作。

7. **父组件的`beforeUpdate`和`updated`钩子函数：**
   - 当父组件的数据发生变化时，会触发`beforeUpdate`钩子函数，此时父组件的数据已经更新，但DOM尚未重新渲染。
   - 紧接着触发`updated`钩子函数，此时父组件的数据已经更新，并且DOM也已经重新渲染。

8. **子组件的`beforeUpdate`和`updated`钩子函数：**
   - 当子组件的数据发生变化时，会触发`beforeUpdate`钩子函数，此时子组件的数据已经更新，但DOM尚未重新渲染。
   - 紧接着触发`updated`钩子函数，此时子组件的数据已经更新，并且DOM也已经重新渲染。

9. **父组件的`beforeDestroy`和`destroyed`钩子函数：**
   - 当父组件被销毁时，会触发`beforeDestroy`钩子函数，此时父组件还未销毁。
   - 紧接着触发`destroyed`钩子函数，父组件已经完全销毁，相关的事件监听和定时器都被清除。

10. **子组件的`beforeDestroy`和`destroyed`钩子函数：**
    - 当子组件被销毁时，会触发`beforeDestroy`钩子函数，此时子组件还未销毁。
    - 紧接着触发`destroyed`钩子函数，子组件已经完全销毁，相关的事件监听和定时器都被清除。

这些生命周期钩子函数用于在不同阶段执行代码，可以用来处理数据、DOM操作、事件监听、清理工作等。理解这些钩子函数的执行顺序有助于编写更复杂的Vue应用时更好地控制组件的行为。

<br/>

### Vuex 和 localStorage 的区别 

公司：高思教育

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/827)
Vuex 和 localStorage 是两种在前端应用中用于管理数据的不同工具，它们有一些重要的区别，下面详细回答：

1. **数据持久性：**
   - **Vuex：** Vuex 是一个状态管理库，它用于在前端应用的不同组件之间共享和管理数据。然而，Vuex 中的数据通常是内存中的，当页面刷新或关闭后，Vuex 中的数据会被清除，因为它不提供数据持久性。
   - **localStorage：** localStorage 是一个浏览器提供的持久化存储机制。数据存储在用户的本地浏览器中，即使页面刷新或关闭，数据仍然存在。

2. **数据存储方式：**
   - **Vuex：** Vuex 存储数据在内存中，通常用于管理应用状态，如用户信息、购物车内容等。
   - **localStorage：** localStorage 存储数据在浏览器的本地存储中，数据以字符串形式存储，可以存储简单的键值对，如配置选项、用户首选项等。

3. **数据容量：**
   - **Vuex：** Vuex通常适用于存储应用的状态和较小量的数据，不适合存储大量数据，因为它在内存中管理，可能会导致性能问题。
   - **localStorage：** localStorage 可以存储较大的数据量，但不建议滥用，因为存储过多数据会影响页面性能。

4. **数据更新和响应：**
   - **Vuex：** Vuex提供了数据的响应式更新机制，当状态发生变化时，相关组件可以自动更新。这使得状态管理和组件通信更容易。
   - **localStorage：** localStorage 存储的数据不具备响应式能力，如果数据变化，需要手动更新数据，通常需要监听存储事件或定期轮询以获取最新数据。

5. **数据安全性：**
   - **Vuex：** Vuex 中的数据相对较安全，因为数据存储在内存中，不容易被外部恶意访问。
   - **localStorage：** 数据存储在本地浏览器中，容易受到跨站脚本攻击 (XSS) 的影响。因此，在存储敏感数据时需要采取额外的安全措施。

6. **使用场景：**
   - **Vuex：** 适用于管理应用的状态、用户登录状态、购物车内容等需要在组件之间共享的数据。
   - **localStorage：** 适用于存储用户首选项、配置选项、本地缓存数据等不需要共享但需要持久化的数据。

总的来说，Vuex 和 localStorage 在数据管理的范围、持久性、响应性、安全性等方面有明显的区别，应根据具体需求选择合适的工具来管理数据。通常，它们可以在应用中一起使用，根据需求将数据存储在内存中（Vuex）或本地浏览器存储中（localStorage）。

<br/>

### Vue 双向绑定原理 

公司：高思教育、安居客

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/824)
Vue 的双向绑定是其核心特性之一，它使得数据模型和视图之间的同步变得简单和高效。下面是 Vue 双向绑定的详细原理：

1. **数据劫持（Object.defineProperty）：** Vue 使用数据劫持来实现双向绑定。在 Vue 初始化过程中，Vue 会遍历数据对象的每个属性，并使用 `Object.defineProperty` 方法将其转换为 getter 和 setter。这样一来，当属性被访问或修改时，Vue 就能捕获到，并执行相应的操作。

2. **模板编译：** 在 Vue 中，使用特定的语法（如 `{{}}`）将数据绑定到 HTML 模板中。在模板编译阶段，Vue 会解析模板中的指令和表达式，并生成一个渲染函数。

3. **Watcher 监听器：** 在模板编译过程中，Vue 会为每个数据绑定创建一个 Watcher 监听器。Watcher 监听器会订阅数据的变化，并在数据变化时触发相应的更新操作。

4. **依赖收集：** 在模板编译过程中，当 Vue 解析到一个数据绑定时，会将该数据绑定的 Watcher 添加到该数据的依赖列表中。这样一来，当数据发生变化时，Vue 就能找到所有依赖于该数据的 Watcher，并通知它们进行更新。

5. **响应式更新：** 当数据发生变化时，Vue 会触发数据对象的 setter 方法。在 setter 方法中，Vue 会通知所有依赖于该数据的 Watcher 进行更新。Watcher 接收到更新通知后，会执行相应的更新操作，将新的数据渲染到视图中。

6. **视图更新：** 在 Watcher 的更新操作中，Vue 会通过虚拟 DOM 的 diff 算法，计算出需要更新的最小 DOM 更改，并将这些更改应用到实际的 DOM 中。这样一来，只有发生变化的部分会被重新渲染，提高了性能。

通过以上步骤，Vue 实现了数据的双向绑定。当数据发生变化时，视图会自动更新；当用户与视图进行交互时，数据也会自动更新。这种双向绑定的机制使得开发者能够更方便地处理数据和视图之间的同步，提高了开发效率。

<br/>

### 说一下路由钩子在 Vue 生命周期的体现？

公司：58

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/820)
在 Vue 中，路由钩子是一种在路由导航过程中执行的函数。它们允许我们在路由切换前、切换后或者在路由切换过程中执行一些逻辑。路由钩子在 Vue 生命周期中的体现如下：

1. **全局前置守卫（beforeEach）：** 全局前置守卫是在路由切换前执行的钩子函数。它们可以用来进行身份验证、权限控制或者其他预处理逻辑。在 Vue 生命周期中，全局前置守卫的执行时机是在 `beforeCreate` 和 `created` 生命周期钩子之间。

2. **全局解析守卫（beforeResolve）：** 全局解析守卫是在路由切换前的异步组件解析完成后执行的钩子函数。它们可以用来确保异步组件在路由切换前已经解析完毕。在 Vue 生命周期中，全局解析守卫的执行时机是在 `beforeRouteEnter` 和 `beforeCreate` 生命周期钩子之间。

3. **全局后置守卫（afterEach）：** 全局后置守卫是在路由切换后执行的钩子函数。它们可以用来进行页面切换后的一些清理工作或者其他后续操作。在 Vue 生命周期中，全局后置守卫的执行时机是在 `destroyed` 生命周期钩子之后。

4. **路由独享守卫（beforeEnter）：** 路由独享守卫是在特定路由配置中定义的钩子函数。它们可以用来对特定路由进行额外的验证或者其他逻辑处理。在 Vue 生命周期中，路由独享守卫的执行时机是在 `beforeRouteEnter` 和 `beforeCreate` 生命周期钩子之间。

5. **组件内的守卫（beforeRouteUpdate、beforeRouteLeave）：** 组件内的守卫是在组件内部定义的钩子函数。`beforeRouteUpdate` 钩子函数在当前路由被复用时调用，可以用来对路由参数的变化进行响应。`beforeRouteLeave` 钩子函数在离开当前路由时调用，可以用来进行离开前的确认提示或者其他处理。

通过使用这些路由钩子函数，我们可以在不同的阶段执行相应的逻辑，实现路由导航过程中的各种需求，例如权限控制、数据加载、页面切换动画等。这些钩子函数的执行时机与 Vue 生命周期的不同阶段相对应，使得我们能够更好地控制和管理路由导航过程中的行为。

<br/>

### 计算属性和普通属性的区别 

公司：58

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/819)
计算属性（Computed Properties）和普通属性（普通数据属性）是Vue.js中的两种不同属性，它们在用法和行为上有一些重要的区别。以下是它们的详细对比：

1. **计算属性（Computed Properties）**：

   - **用途：** 计算属性用于派生出一个新的属性，这个属性的值是基于一个或多个已有属性计算得到的。它通常用于处理对数据的复杂转换或计算。
   
   - **特点：** 
     - 基于依赖属性（data属性或其他计算属性）的值进行计算。
     - 仅在其依赖的属性发生变化时才重新计算，具有缓存功能，避免不必要的计算。
     - 计算属性是响应式的，当依赖属性变化时，计算属性的值会自动更新。

   - **示例：**
     ```javascript
     computed: {
       fullName() {
         return this.firstName + ' ' + this.lastName;
       }
     }
     ```

2. **普通属性（普通数据属性）**：

   - **用途：** 普通属性是存储数据的属性，用于保存组件中的状态信息。
   
   - **特点：** 
     - 普通属性的值在组件创建后会立即计算，并且不依赖于其他属性的值。
     - 普通属性的值在变化时，不会自动触发其他属性或视图的更新。

   - **示例：**
     ```javascript
     data() {
       return {
         count: 0
       };
     }
     ```

**主要区别：**

1. **自动响应：** 计算属性具有自动响应性，当其依赖的属性变化时，计算属性会自动重新计算并更新。而普通属性不会自动响应，需要手动触发更新。

2. **计算时机：** 计算属性是按需计算的，只有在需要时才计算，而普通属性在组件创建时立即计算。

3. **性能优化：** 计算属性可以缓存计算结果，避免不必要的重复计算，因此在处理复杂逻辑时通常更高效。普通属性不具备这种缓存功能。

4. **可读性：** 计算属性通常用于计算和派生属性，使代码更具可读性和可维护性。普通属性用于存储状态和数据。

总之，计算属性和普通属性都有各自的用途，你应该根据需求选择合适的属性类型。计算属性适用于需要派生数据的情况，而普通属性适用于简单的状态

<br/>

### 描述下自定义指令(你是怎么用自定义指令的) 

公司：58

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/818)
自定义指令（Custom Directives）是Vue.js中一种强大的功能，用于在DOM元素上添加自定义行为。通过自定义指令，你可以直接操作DOM，添加事件监听器、样式绑定、动态修改元素等。下面是详细的描述和使用自定义指令的步骤：

1. **创建自定义指令：** 首先，你需要使用`Vue.directive`方法来创建一个自定义指令。该方法接受两个参数：指令名称和一个包含指令定义的对象。

   - **指令名称：** 指令名称通常以`v-`开头，例如`v-custom-directive`。
   
   - **指令定义对象：** 指令定义对象包含一系列钩子函数，用于定义指令的行为。常用的钩子函数有：
     - `bind`：指令绑定到元素时调用，可以在这里进行一次性的初始化设置。
     - `inserted`：元素被插入到父节点时调用。
     - `update`：元素所在组件的VNode更新时调用，可以获取新的值和旧的值。
     - `componentUpdated`：元素所在组件的VNode及其子VNode全部更新后调用。
     - `unbind`：指令与元素解绑时调用，可以在这里进行清理工作。

2. **使用自定义指令：** 创建自定义指令后，你可以在Vue模板中使用它。使用自定义指令的方式是在元素上使用`v-`前缀，后面跟上指令名称和指令的参数。

   - **参数：** 指令可以接受参数，参数可以是静态的，也可以是动态的。例如，`v-custom-directive:arg.modifier="value"`。

3. **指令定义对象的钩子函数：** 在指令定义对象中，你可以定义各种钩子函数来实现指令的具体行为。

   - **钩子函数的参数：** 钩子函数可以接受一些参数，包括`el`（指令所绑定的元素）、`binding`（一个对象，包含指令的信息）、`vnode`（Vue编译生成的虚拟节点）和`oldVnode`（上一个虚拟节点）等。

4. **操作DOM：** 在钩子函数中，你可以通过操作`el`参数来直接操作DOM元素。例如，添加事件监听器、修改元素样式、添加动画效果等。

   - **示例：** 下面是一个简单的自定义指令示例，用于将元素的背景色设置为红色：
     ```javascript
     Vue.directive('custom-directive', {
       bind: function(el) {
         el.style.backgroundColor = 'red';
       }
     });
     ```

     ```html
     <div v-custom-directive>这是一个自定义指令示例</div>
     ```

以上就是使用自定义指令的详细步骤。通过自定义指令，你可以在Vue应用中实现更灵活和复杂的DOM操作，提高代码的可重用性和可维护性。

<br/>

### 说一下 Vue 中所有带\$的方法 

公司：58

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/817)
在Vue.js中，有一些带有`$`前缀的方法和属性，它们是Vue实例的内置方法和属性，提供了一些特定的功能和操作。下面是Vue中常用的带有`$`前缀的方法和属性的详细说明：

1. **\$mount()：** 该方法用于手动挂载Vue实例到一个DOM元素上。如果Vue实例在创建时没有指定`el`选项，则需要使用`$mount()`方法手动挂载。

2. **\$nextTick()：** 该方法用于在DOM更新之后执行回调函数。Vue在更新DOM时是异步执行的，所以如果你想在DOM更新后执行一些操作，可以使用`$nextTick()`方法。

3. **\$watch()：** 该方法用于监听Vue实例中数据的变化。通过`$watch()`方法，你可以监听一个表达式的变化，并在变化时执行回调函数。

4. **\$set()：** 该方法用于在Vue实例中添加响应式属性。如果你需要在Vue实例创建后动态添加属性，并希望这些属性是响应式的，可以使用`$set()`方法。

5. **\$delete()：** 该方法用于在Vue实例中删除属性。如果你需要删除Vue实例中的属性，并且希望这个操作是响应式的，可以使用`$delete()`方法。

6. **\$on()：** 该方法用于监听自定义事件。通过`$on()`方法，你可以在Vue实例中监听一个自定义事件，并在事件触发时执行回调函数。

7. **\$emit()：** 该方法用于触发自定义事件。通过`$emit()`方法，你可以在Vue实例中触发一个自定义事件，并传递参数给事件处理函数。

8. **\$refs：** 这是一个对象，包含了Vue实例中所有拥有`ref`属性的子组件或DOM元素。通过`$refs`对象，你可以直接访问这些子组件或DOM元素。

9. **\$router：** 这是Vue Router的实例，用于进行路由导航。通过`$router`对象，你可以访问和操作路由相关的方法和属性。

10. **\$route：** 这是当前路由的信息对象，包含了当前路由的路径、参数、查询等信息。通过`$route`对象，你可以访问和使用当前路由的信息。

以上是Vue中常用的带有`$`前缀的方法和属性的详细说明。它们提供了一些方便的功能和操作，帮助你更好地开发和管理Vue应用。

<br/>

### Vue-router 除了 router-link 怎么实现跳转 

公司：安居客

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/810)
在Vue Router中，除了使用 `<router-link>` 组件外，你还可以使用编程式导航来实现页面跳转。编程式导航意味着通过JavaScript代码来触发路由的切换，这通常在Vue组件中使用。下面是详细说明如何进行编程式导航：

1. **使用 `this.$router.push()`：**

   `this.$router.push()` 方法允许你通过提供目标路由的路径或命名路由来进行跳转。它会向路由历史栈添加一个新的记录，然后导航到指定的页面。例如：

   ```vue
   <template>
     <button @click="navigateToAbout">Go to About</button>
   </template>
   
   <script>
   export default {
     methods: {
       navigateToAbout() {
         this.$router.push('/about'); // 通过路径跳转
       }
     }
   }
   </script>
   ```

2. **使用 `this.$router.replace()`：**

   `this.$router.replace()` 方法与 `push` 方法类似，但它不会在路由历史中留下记录，而是直接替换当前路由记录。通常用于实现返回按钮的功能。例如：

   ```vue
   <template>
     <button @click="replaceWithAbout">Replace with About</button>
   </template>
   
   <script>
   export default {
     methods: {
       replaceWithAbout() {
         this.$router.replace('/about'); // 替换当前路由
       }
     }
   }
   </script>
   ```

3. **使用 `this.$router.go()`：**

   `this.$router.go()` 方法允许你在路由历史记录中向前或向后导航。例如，`this.$router.go(-1)` 表示返回上一页，`this.$router.go(1)` 表示前进到下一页。

   ```vue
   <template>
     <button @click="goBack">Go Back</button>
   </template>
   
   <script>
   export default {
     methods: {
       goBack() {
         this.$router.go(-1); // 返回上一页
       }
     }
   }
   </script>
   ```

这些方法允许你在Vue组件中以编程方式实现页面跳转和导航，而不依赖于`<router-link>`组件。你可以根据具体的需求选择适合的方法来进行路由导航。

<br/>

### 说一下 Vue 的 keep-alive 是如何实现的，具体缓存的是什么？

公司：快手

分类：Vue

[答案&解析](https://github.com/lgwebdream/FE-Interview/issues/207)
在Vue中，`<keep-alive>` 是一个内置组件，用于缓存动态组件或组件的状态，以避免重复渲染和销毁。它的实现原理是将被包裹的组件进行缓存，而不是直接销毁和重新创建。

具体来说，`<keep-alive>` 组件会在组件切换时，将当前组件缓存起来，而不是销毁它。当再次切换回该组件时，会直接从缓存中取出并重新渲染，而不是重新创建一个新的组件实例。

`<keep-alive>` 组件的缓存是基于组件的 `name` 属性进行的。当一个组件被包裹在 `<keep-alive>` 中时，Vue会根据组件的 `name` 属性来进行缓存和匹配。如果两个组件的 `name` 属性相同，那么它们会被视为同一个组件，从而实现缓存和复用。

缓存的内容包括组件的状态、DOM结构以及相关的数据。当组件被缓存时，它的状态会被保留，包括已经触发的生命周期钩子函数、已经渲染的DOM元素等。这样在组件再次被激活时，可以直接使用之前缓存的状态和DOM结构，避免了重新创建和渲染的开销。

需要注意的是，`<keep-alive>` 组件只会缓存有状态的组件，即那些包含数据和生命周期钩子函数的组件。无状态的组件，如纯展示型组件，不会被缓存。

使用 `<keep-alive>` 组件可以提高应用的性能，特别是在频繁切换组件的场景下，可以减少不必要的渲染和销毁操作，提升用户体验。

下面是一个示例，展示如何使用 `<keep-alive>` 组件：

```vue
<template>
  <div>
    <button @click="toggleComponent">Toggle Component</button>
    <keep-alive>
      <component :is="currentComponent"></component>
    </keep-alive>
  </div>
</template>

<script>
import ComponentA from './ComponentA.vue';
import ComponentB from './ComponentB.vue';

export default {
  data() {
    return {
      currentComponent: 'ComponentA',
    };
  },
  methods: {
    toggleComponent() {
      this.currentComponent = this.currentComponent === 'ComponentA' ? 'ComponentB' : 'ComponentA';
    },
  },
  components: {
    ComponentA,
    ComponentB,
  },
};
</script>
```

在上面的示例中，`<keep-alive>` 组件包裹了一个动态组件，根据 `currentComponent` 的值来切换显示不同的组件。当切换组件时，被缓存的组件会保留其状态，而不是重新创建。这样可以提高组件的切换性能。

<br/>

